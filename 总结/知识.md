# 阻塞与非阻塞 I/O

在 I/O 处理中，"阻塞"和"非阻塞"是两个重要概念：

## 阻塞 I/O
- **定义**：当线程进行 I/O 操作（如读取文件或网络请求）时，如果操作无法立即完成，线程会挂起，直到 I/O 操作完成。
- **优点**：
  - 实现简单。
  - 适合简单任务。
- **缺点**：
  - 在 I/O 操作慢时会浪费 CPU 资源，导致效率低下。

## 非阻塞 I/O
- **定义**：线程执行 I/O 操作时，如果操作无法立即完成，线程不会挂起，而是继续执行其他操作。
- **优点**：
  - 提高并发性。
  - 更有效利用 CPU 资源。
- **缺点**：
  - 实现复杂，需要处理更多状态和错误。

## 总结
阻塞 I/O 适合简单场景，而非阻塞 I/O 更适合高性能和高并发应用。
## I/O 操作的同步与异步

### 1. 同步 I/O
- **定义**: 在执行 I/O 操作时，调用线程会被阻塞，直到 I/O 操作完成。
- **特点**:
  - 简单易用。
  - 适用于 I/O 操作较快的场景。
  
### 2. 异步 I/O
- **定义**: I/O 操作在后台进行，调用线程不会被阻塞，可以继续执行其他任务。
- **特点**:
  - 提高了程序的并发性。
  - 适用于 I/O 操作耗时较长的场景。

### 3. 应用场景
- **同步 I/O**: 适合小规模应用或对性能要求不高的场景。
- **异步 I/O**: 适合高性能、高并发的网络应用，如服务器端的请求处理。

### 4. 示例代码
```c
// 同步 I/O 示例
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

// 异步 I/O 示例 (伪代码)
async_recv(int sockfd, void *buf, size_t len, callback);
