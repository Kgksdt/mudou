## 继承与多态

#### 1. 虚函数
一个类里定义了虚函数：
<p>编译阶段 -> 产生一个虚函数表，在类地址的头部存有该虚函数表的指针，虚函数表定义了 RTTI(用于类型检测) 和 虚函数地址。 加载在.data区
<p>运行阶段 -> 对象调用成员时对虚函数表内函数匹配，形成动态绑定。
派生类可以重写基类的虚函数，因为在同一作用域。

#### 2. 哪些函数不能实现成虚函数？
虚函数依赖 : 虚函数能产生地址存储在vftable且 对象必须存在。
<p>构造函数 调用的任何函数都是静态绑定
<p>static静态方法 不依赖对象  

#### 3. 为什么析构函数要携程虚函数？
基类的析构函数是虚函数，派生类析构函数自动变成虚函数。<P>基类的指针指向堆上派生类对象时候，delete 基类指针时，且基类析构函数不是虚函数，那么调用虚构函数时候是静态绑定，不会调用派生类的析构函数，这时候就会发生内存泄漏。

#### 4. 虚函数的调用一定是动态绑定？
不是，在类的构造函数中，调用构造函数，也是静态绑定（构造函数调用其他函数，不会发生动态绑定，原因是没有初始化类对象）
如果不是通过引用或者指针调用，就是静态绑定

#### 5. 解释多态
+ 静态多态 ；函数重载 函数模板(函数模板、类模板)
+ 动态多态 ：咋爱继承结构中，基类指针(引用)指向派生类对象，通过该指针(引用)调用同名覆盖方法(虚函数)。指针指向哪个派生类对象，就会调用哪个派生类对象的覆盖方法。

#### 6.菱形继承
多继承时候，可能存在派生类有多份基类间接数据，解决方案：继承地方采用虚继承，使间接备份基类数据不会重复。


#### 四种类型转换方式
+ const_cast: 去掉常量属性的一个类型转换（必须是指针或者引用 ）
+ static_cast: 提供编译器认为安全的类型转换如int->double ×
+ reinterpret_cast: 类似于c风格的强制类型转换int->dou ble √
+ dynamic_cast: 主要用于继承结构中，可以支持RTTI类型识别的上下转换

## STL
vector特点:动态数组，内存是连续的，2倍的方式进行扩容。
deque特点:动态开辟的二维数组空间，第二维是固定长度的数组空间

#### vector和deque之间的区别？list之间的区别？
| | vector | deque| list|
|---|---|---|-
|底层数据结构|动态数组|动态二维数组|双向循环链表|
|复杂度|后O(1)前O(n)查O(1)|后O(1)前O(1)查O(1)|后O(1)前O(1)查O(n)|
|内存使用效率|空间必须是连续|不需要内存空间是连续的|高|
|插删效率|vector效率相比更低一点|deque效率相比更高一点|高


## C++ 智能指针

在 C++11 中，引入了几种智能指针，主要包括：

### 1. `unique_ptr`
- **特性**: 
  - 独占拥有权：一个 `unique_ptr` 只能拥有一个对象的指针，不能被复制。
  - 支持移动语义，可以通过 `std::move` 进行转移。
- **使用场景**: 
  - 当你只需要一个所有者管理一个对象的生命周期时，适合使用 `unique_ptr`。

### 2. `shared_ptr`
- **特性**: 
  - 共享拥有权：多个 `shared_ptr` 可以指向同一个对象，使用引用计数来管理对象的生命周期。
  - 当最后一个指向对象的 `shared_ptr` 被销毁或重置时，对象才会被释放。
- **使用场景**: 
  - 当需要多个所有者共享同一资源时，例如在多个组件中共享数据，适合使用 `shared_ptr`。

### 3. `weak_ptr`
- **特性**: 
  - 弱引用：不增加对象的引用计数，因此不会影响对象的生命周期。
  - 主要与 `shared_ptr` 配合使用，解决循环引用问题。
- **使用场景**: 
  - 适合用于缓存和观察者模式，使得观察者可以在被观察对象存在时进行观察，而不影响其生命周期。

### 4. 对比总结

| 智能指针    | 拥有权类型   | 复制特性       | 生命周期管理              | 主要用途                                 |
|-----------|----------|------------|-----------------------|------------------------------------|
| `unique_ptr` | 独占拥有权   | 不支持复制     | 自动释放               | 资源独占管理                              |
| `shared_ptr` | 共享拥有权   | 支持复制       | 通过引用计数自动管理      | 多个所有者共享资源                         |
| `weak_ptr`   | 弱引用      | 不支持复制     | 无所有权，不能直接释放     | 防止循环引用，作为 `shared_ptr` 的辅助指针 |

## 面试回答示例

如果在面试中被问到“智能指针都有什么，有什么区别”，你可以这样回答：

“在 C++11 中，有三种主要的智能指针：`unique_ptr`、`shared_ptr` 和 `weak_ptr`。`unique_ptr` 提供独占的拥有权，只能有一个指针指向一个对象，适用于不需要共享资源的情况。`shared_ptr` 允许多个指针共享同一个对象，使用引用计数来管理生命周期，适用于需要多个所有者的场景。`weak_ptr` 是一种弱引用，主要用来打破循环引用的问题，它不增加引用计数，因此不会影响对象的生命周期。使用 `weak_ptr` 可以安全地观察对象的状态而不干扰其释放。”

## 操作系统
### 阻塞 非阻塞 同步 异步
- 数据准备
    + 阻塞:   阻塞等到数据到来
    + 非阻塞: 不会挂起，继续执行其他操作
- 数据读写
    + 同步: 等待从操作系统读取数据，应用程序再接收
    + 异步: 直接让操作系统把数据读到应用程序，完成时候通知应用程序。  
- 并发异步
    + 异步: a给b任务和信号点，a继续进行其他任务，b进行任务并达到信号点时候通知a，a接受任务。